Function Name,State Variables Modified,Can Transfer Ether
"mul(uint256,uint256)",,False
"div(uint256,uint256)",,False
"sub(uint256,uint256)",,False
"add(uint256,uint256)",,False
recieveFunds(),,False
"mint(address,uint256)",,False
getMaxTokenAvaliable(),,False
finishMinting(),,False
GetTime(),,False
getAllTimes(),"_startBlock, _startBlock, _startBlock, delayOfICOEND, _startBlock, delayOfPreICO, _startBlock, delayOfPreICO, _startBlock, delayOfICO1, _startBlock, delayOfICO1, _startBlock, delayOfICO2, _startBlock, delayOfICO2, _startBlock, _startBlock, delayOfICOEND",False
CABCoinICO(uint256),"_startBlock, _startBlock",False
"SetContracts(address,address)","tokenAddress, tokenAddress, coin, devTeam",False
getMaxEther(),coin,False
isAfterICO(),,False
getCabCoinsAmount(),"_startBlock, _startBlock, delayOfPreICO, maxTokenSupplyPreICO, coin, PRICE_PREICO, _startBlock, delayOfICO1, maxTokenSupplyICO1, coin, PRICE_ICO1, _startBlock, delayOfICO2, maxTokenSupplyICO2, coin, PRICE_ICO2, _startBlock, delayOfICOEND, maxTokenSupplyICOEND, coin, PRICE_ICO4",False
function()payablepublic{if(isAfterICO()&&coin.totalSupply()<minimumGoal){this.refund.value(msg.value)(msg.sender);}else{if(msg.value==0){sendAllFunds();}else{if(isAfterICO()==false){this.buy.value(msg.value)(msg.sender);}else{revert();}}}}(),"coin, minimumGoal",True
buy(address),"owner, _startBlock, coin, coin, TEAM_SHARE_PERCENTAGE, TEAM_SHARE_PERCENTAGE, TEAM_SHARE_PERCENTAGE, TEAM_SHARE_PERCENTAGE, coin, owner, coin, devTeam, ethGiven, owner, ethGiven, owner, coin, preICOHolders, owner, devTeam, PRE_ICO_RISK_PERCENTAGE, coin, owner, coin, devTeam, ethGiven, owner, ethGiven, owner",True
sendAllFunds(),"coin, minimumGoal, devTeam",False
refund(address),"ethGiven, coin, minimumGoal, ethGiven, ethGiven, preICOHolders, PRE_ICO_RISK_PERCENTAGE",True
