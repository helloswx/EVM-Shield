Function Name,State Variables Modified,Can Transfer Ether
constructor(),"owner, newOwner",True
transferOwnership(address),newOwner,False
acceptOwnership(),"newOwner, owner, owner, newOwner",True
balanceOf(address),,False
"transfer(address,uint256)",,False
burn(uint256),,False
started(),,False
ended(),,False
startTime(),,False
endTime(),,False
totalTokens(),,False
remainingTokens(),,False
price(),,False
"buyTokensFor(address,bytes32,uint,uint8,bytes32,bytes32,uint8,bytes32,bytes32)",,False
"buyTokens(bytes32,uint,uint8,bytes32,bytes32)",,True
"hasher(address,bytes32,uint256)",,False
"constructor(address,uint256,uint256,uint256,uint256,uint256)","tokenSaleContract, soldTokens, remainingTokens, tokenPrice, etherMinimum, startTime, endTime",False
"setTime(uint256,uint256)","startTime, endTime",False
changeMinimum(uint256),etherMinimum,False
started(),"startTime, remainingTokens",False
ended(),"endTime, remainingTokens",False
startTime(),startTime,False
endTime(),endTime,False
totalTokens(),"remainingTokens, soldTokens",False
remainingTokens(),remainingTokens,False
price(),"tokenPrice, tokenSaleContract",False
function()publicpayable{takeEther(msg.sender);}(),,True
refundEther(address),"etherUser, etherUser, pendingTokenUser",True
"withdraw(address,uint256)",,True
userBalance(address),"pendingTokenUser, tokenUser, etherUser",False
"constructor(address,address,,,uint256,uint256)","tokenContract, decimals, tokenContract, tokenPrice, milestoneSystem",False
forwardEther(),milestoneSystem,True
"sendTokens(address,uint256)",tokenContract,True
addRC(address),rc,False
"withdrawTokens(address,uint256)",tokenContract,True
setTokenContract(address),tokenContract,False
"constructor(address,address,,,uint256,uint256)","wallet, tokenContract, tokenSaleContract, time, funds, activeSupply, tokenPrice",True
"distrust(address,uint,bytes)","tokenContract, locked, time, step, timeframeMilestone, time, step, time, step, timeframeDeath, funds, step, locked, endTimeToReturnTokens, balance, step, balance, step, tokenDistrusted, step, tokenDistrusted, step, tokenDistrusted, step, activeSupply, locked, locked, endTimeToReturnTokens, timeframeDeath",True
"tokenFallback(address,uint,bytes)",,False
"receiveApproval(address,uint,bytes)",tokenContract,True
trust(uint8),"balance, balance, balance, tokenDistrusted, tokenDistrusted, tokenContract, tokenDistrusted, step, activeSupply, locked, locked, endTimeToReturnTokens",True
refundMe(),"locked, endTimeToReturnTokens, balance, step, balance, step, tokenContract, tokenDistrusted, step",True
ownerWithdraw(),"locked, time, step, funds, step, funds, step, funds, step, step, step, time, step",True
"ownerWithdrawTokens(address,address,uint256)",tokenContract,True
setWallet(address),wallet,False
"function()publicpayable{require(msg.sender==address(tokenSaleContract),""msg.sender == address(tokenSaleContract)"");if(etherReceived<funds[0]){require(wallet!=address(0),""wallet != address(0)"");wallet.transfer(msg.value);}etherReceived=etherReceived.add(msg.value);}()","tokenSaleContract, etherReceived, funds, wallet, wallet, etherReceived, etherReceived",True
