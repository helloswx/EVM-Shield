Function Name,State Variables Modified,Can Transfer Ether
"recover(bytes32,bytes)",,False
"getCEOHashing(address,uint256)",,False
"setCEO(address,bytes)","cfoAddress, cooAddress, ceoAddress, CLevelTxCount_",True
"getCFOHashing(address,uint256)",,False
"setCFO(address,bytes)","ceoAddress, cooAddress, cfoAddress, CLevelTxCount_",True
"getCOOHashing(address,uint256)",,False
"setCOO(address,bytes)","ceoAddress, cfoAddress, cooAddress, CLevelTxCount_",True
getNonce(),,True
"transfer(address,uint)",,False
balanceOf(address),,False
"constructor(address,address,address,address,uint256)","ceoAddress, cfoAddress, cooAddress, totalToken, decimals, systemAddress",False
"recover(bytes32,bytes)",,False
getNonces(address),,True
"getTokenAddressHashing(address,uint256)",,False
"setTokenAddress(address,bytes)",token,True
setPreSaleEnd(bool),preSaleEnd,False
isPreSaleEnd(),preSaleEnd,False
setDeklaPrice(uint256),deklaTokenPrice,True
"function()externalpayable{require(!preSaleEnd);uint256amount=msg.value.div(deklaTokenPrice);amount=amount*(10**decimals);require(amount>=deklaMinimum);soldToken=soldToken.add(amount);if(soldToken<totalToken){amount=amount.add(amount.mul(bonus).div(10000));}deklaTokenOf[msg.sender]=deklaTokenOf[msg.sender].add(amount);emitBuyDeklaSuccessful(amount,msg.sender);}()","preSaleEnd, deklaTokenPrice, decimals, deklaMinimum, soldToken, soldToken, soldToken, totalToken, bonus",True
"getPromoBonusHashing(address,uint16,uint256)",,False
"buyDkl(uint16,bytes)","preSaleEnd, systemAddress, deklaTokenPrice, decimals, deklaMinimum, soldToken, soldToken, soldToken, totalToken",True
getDeklaTokenOf(address),,False
calculateDekla(uint256),"deklaTokenPrice, deklaTokenPrice",False
sendDekla(address),"token, token",True
sendDeklaToMultipleUsers(),"token, token",True
"withdrawEthHashing(address,uint256)",,False
"withdrawEth(address,bytes)",,True
"withdrawDeklaHashing(address,uint256)",,False
"withdrawDekla(address,bytes)","token, soldToken, token, soldToken",True
